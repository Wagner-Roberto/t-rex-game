{"entries":[{"timestamp":1740222959867,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"0\" y=\"0\""],[0,"></b"]],"start1":67,"start2":67,"length1":20,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"208\" y=\"1\""],[0,"></b"]],"start1":107,"start2":107,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n    basic.showLeds(`\n        . . . . .\n        . . . . .\n        . . . . .\n        . . . . .\n        # # # # #\n    `)\n\n\n    player()\n})\n\nfunction player(): boolean {\n    return led.point(0, 0);\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":223,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":228,"start2":228,"length1":32,"length2":31}]}]},{"timestamp":1740223541072,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[1,"basic.showLeds(`\n        . . . . .\n        . . . . .\n        . . . . .\n        . . . . .\n        # # # # #\n    `)\n\n\n    "],[0,"player()"],[-1,"\n    "],[0,"\n})\n\n"],[-1,"\n\n"],[0,"func"]],"start1":28,"start2":28,"length1":28,"length2":141},{"diffs":[[0,"er()"],[1,": boolean"],[0," {\n    "],[-1,"let player = game.createSprite(0, 5)\n\n    "],[1,"return led.point(0, 0);"],[0,"\n}"]],"start1":178,"start2":178,"length1":55,"length2":45}]}]},{"timestamp":1740224132387,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n    "],[1,"player()"],[0,"\n    \n})"]],"start1":24,"start2":24,"length1":16,"length2":24},{"diffs":[[0,"})\n\n"],[-1,"type Sprite = any; // Substitua 'any' pelo tipo real do sprite, se disponível\n\nclass Player {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push("],[1,"\n\nfunction player() {\n    let player = "],[0,"game"]],"start1":46,"start2":46,"length1":418,"length2":47},{"diffs":[[0,"ite("],[-1,"x, y));\n    }\n}\n\n// Cria uma instância da classe Player\nlet playerLive = new Player();"],[1,"0, 5)\n\n    \n}"]],"start1":103,"start2":103,"length1":90,"length2":17}]}]},{"timestamp":1740224727539,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"player()\n})\n\nlet Sprite = new Create"],[1,"\n})\n\ntype Sprite = any; // Substitua 'any' pelo tipo real do sprite, se disponível\n\nclass Player {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: "],[0,"Sprite"],[-1,"();\n\nfunction player() {\n    let pos = Sprite.add"],[1,"[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.create"],[0,"Sprite("],[-1,"1, 4)\n}"],[1,"x, y));\n    }\n}\n\n// Cria uma instância da classe Player\nlet playerLive = new Player();"]],"start1":33,"start2":33,"length1":109,"length2":523}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"createsprite.ts\""],[0,"\n   "]],"start1":215,"start2":215,"length1":35,"length2":8}]},{"type":"added","filename":"createsprite.ts","value":"type Sprite = game.LedSprite\n\nclass CreateSprite {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.createSprite(x, y));\n    }\n}"}]},{"timestamp":1740225319118,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"let player = new Player();\n\n\n\n\nbasic.forever(function () {\n\n"],[1,"basic.forever(function () {\n    \n    player()\n})\n\nlet Sprite = new CreateSprite();\n\nfunction player() {\n    let pos = Sprite.addSprite(1, 4)"],[0,"\n}"],[-1,")"]],"start1":0,"start2":0,"length1":63,"length2":142}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".ts\""],[-1,",\n        \"player.ts\""],[0,"\n   "]],"start1":242,"start2":242,"length1":29,"length2":8}]},{"type":"added","filename":"player.ts","value":"class Player {\n    private sprite: Sprite;\n\n    constructor() {\n        // Cria um sprite na posição inicial (0, 0)\n        this.sprite = game.createSprite(1, 4);\n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n}\n\nfunction jump() {\n    \n}"}]},{"timestamp":1740225892400,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,";\n\n\n"],[-1,"\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n});"],[0,"\n\nba"]],"start1":25,"start2":25,"length1":77,"length2":8},{"diffs":[[0," {\n\n"],[-1,"    "],[0,"\n})"]],"start1":56,"start2":56,"length1":11,"length2":7}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"machine-learning\": \"github:microbit-foundation/pxt-microbit-ml#v1.0.10\""],[0,"\n   "]],"start1":131,"start2":131,"length1":90,"length2":8}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"ite;"],[-1,"\n    private isJumping: boolean = false;\n    private initialY: number;"],[0,"\n\n  "]],"start1":38,"start2":38,"length1":78,"length2":8},{"diffs":[[0,"  }\n"],[-1,"\n    jump(): void {\n        if (!this.isJumping) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n\n            basic.pause(300);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            this.isJumping = false; // Marca que o pulo terminou\n        }\n    }\n}\n"],[1,"}\n\nfunction jump() {\n    \n}"]],"start1":285,"start2":285,"length1":447,"length2":31}]}]},{"timestamp":1740226490664,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"= false;"],[1,"\n    private initialY: number;"],[0,"\n\n    co"]],"start1":74,"start2":74,"length1":16,"length2":46},{"diffs":[[0," }\n\n"],[-1,"    getPosition(): number {\n        return this.sprite.getY();\n    }\n\n"],[0,"    "]],"start1":356,"start2":356,"length1":78,"length2":8},{"diffs":[[0,"        if ("],[1,"!"],[0,"this.isJumpi"]],"start1":379,"start2":379,"length1":24,"length2":25},{"diffs":[[0,"ping"],[-1," === false"],[0,") { "]],"start1":402,"start2":402,"length1":18,"length2":8},{"diffs":[[0,"use("],[-1,"100);\n\n            this.setPosition(2);\n\n            basic.pause(100);\n\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            // Verifica se a posição é 4 antes de marcar o pulo como terminado\n            if (this.getPosition() === 4) {\n    "],[1,"300);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n"],[0,"    "]],"start1":623,"start2":623,"length1":357,"length2":100},{"diffs":[[0,"nou\n"],[-1,"            }\n"],[0,"    "]],"start1":780,"start2":780,"length1":22,"length2":8}]}]},{"timestamp":1740227089282,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    if(player.isJumping === false){\n    "],[0,"    "]],"start1":72,"start2":72,"length1":48,"length2":8},{"diffs":[[0,"();\n"],[-1,"    }\n"],[0,"});\n"]],"start1":91,"start2":91,"length1":14,"length2":8},{"diffs":[[0,"n () {\n\n"],[-1,"    \n"],[0,"    \n})"]],"start1":121,"start2":121,"length1":20,"length2":15}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"neopixel\": \"github:microsoft/pxt-neopixel#v0.7.6"],[1,"machine-learning\": \"github:microbit-foundation/pxt-microbit-ml#v1.0.10"],[0,"\"\n  "]],"start1":142,"start2":142,"length1":56,"length2":78}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"   p"],[-1,"ublic"],[1,"rivate"],[0," isJ"]],"start1":44,"start2":44,"length1":13,"length2":14},{"diffs":[[0,"4);\n"],[-1,"        this.\n        \n"],[0,"    "]],"start1":199,"start2":199,"length1":31,"length2":8},{"diffs":[[0,"(y);\n    }\n\n"],[1,"    getPosition(): number {\n        return this.sprite.getY();\n    }\n\n"],[0,"    jump(): "]],"start1":318,"start2":318,"length1":24,"length2":94},{"diffs":[[0,"    "],[-1,"basic.pause(200)\n\n"],[1,"// Verifica se a posição é 4 antes de marcar o pulo como terminado\n            if (this.getPosition() === 4) {\n    "],[0,"    "]],"start1":906,"start2":906,"length1":26,"length2":123},{"diffs":[[0,"terminou"],[1,"\n"],[0,"        "]],"start1":1081,"start2":1081,"length1":16,"length2":17},{"diffs":[[0,"        "],[1,"}"],[0,"\n       "]],"start1":1094,"start2":1094,"length1":16,"length2":17}]}]},{"timestamp":1740227687025,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"lse;"],[-1,"\n    private color: number;"],[0,"\n\n  "]],"start1":77,"start2":77,"length1":35,"length2":8},{"diffs":[[0,"    "],[-1,"\n        // Define uma cor para o jogador (no formato RGB)\n        this.color = neopixel.rgb(0, 255, 255); // Ciano (R=0, G=255, B=255)\n\n        // Aplica a cor ao NeoPixel (ou ao LED correspondente)\n        this.applyColor();\n        \n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    // Método para aplicar a cor ao NeoPixel\n    private applyColor(): void {\n        // Aqui você pode usar a biblioteca NeoPixel para definir a cor do LED\n        // Exemplo: neopixel.setPixelColor(0, this.color); // Define a cor do primeiro LED\n        // Nota: O método exato depende da biblioteca que você está usando.\n        // Substitua pelo método correto da sua biblioteca.\n        neopixel.create(0, this.color); // Exemplo hipotético\n        neopixel.show(); // Atualiza o LED com a nova cor"],[1,"this.\n        \n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);"],[0,"\n   "]],"start1":206,"start2":206,"length1":874,"length2":142}]}]},{"timestamp":1740227881605,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ne\": \"*\""],[1,",\n        \"neopixel\": \"github:microsoft/pxt-neopixel#v0.7.6\""],[0,"\n    },\n"]],"start1":127,"start2":127,"length1":16,"length2":76}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0," false;\n"],[1,"    private color: number;"],[0,"\n\n    co"]],"start1":74,"start2":74,"length1":16,"length2":42},{"diffs":[[0,"    "],[-1,"}\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);"],[1,"    \n        // Define uma cor para o jogador (no formato RGB)\n        this.color = neopixel.rgb(0, 255, 255); // Ciano (R=0, G=255, B=255)\n\n        // Aplica a cor ao NeoPixel (ou ao LED correspondente)\n        this.applyColor();\n        \n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    // Método para aplicar a cor ao NeoPixel\n    private applyColor(): void {\n        // Aqui você pode usar a biblioteca NeoPixel para definir a cor do LED\n        // Exemplo: neopixel.setPixelColor(0, this.color); // Define a cor do primeiro LED\n        // Nota: O método exato depende da biblioteca que você está usando.\n        // Substitua pelo método correto da sua biblioteca.\n        neopixel.create(0, this.color); // Exemplo hipotético\n        neopixel.show(); // Atualiza o LED com a nova cor"],[0,"\n   "]],"start1":229,"start2":229,"length1":123,"length2":878}]}]},{"timestamp":1740228479806,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"on () {\n    "],[1,"if(player.isJumping === false){"],[0,"\n        pla"]],"start1":68,"start2":68,"length1":24,"length2":55}]}]},{"timestamp":1740229545206,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"jump();\n"],[1,"    }\n"],[0,"});\n\nbas"]],"start1":96,"start2":96,"length1":16,"length2":22}]}]},{"timestamp":1740229648428,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"player.jump();\n});\n\ninput.onButtonPressed(Button.A, function () {\n"],[1,"\n    "],[0,"    "]],"start1":76,"start2":76,"length1":74,"length2":13},{"diffs":[[0,"n () {\n\n"],[1,"    \n    \n"],[0,"})"]],"start1":130,"start2":130,"length1":10,"length2":20}]}]},{"timestamp":1740230401601,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"true && true"],[0,"\n})"]],"start1":194,"start2":194,"length1":19,"length2":7}]}]},{"timestamp":1740230408128,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"on () {\n"],[1,"true && true"],[0,"\n})"]],"start1":190,"start2":190,"length1":11,"length2":23}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".ts\""],[-1,",\n        \"obstacle.ts\""],[0,"\n   "]],"start1":263,"start2":263,"length1":31,"length2":8}]},{"type":"added","filename":"obstacle.ts","value":"// Adicione seu código aqui\n"}]},{"timestamp":1740230974633,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"0\"><"],[-1,"statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let player = new Player();\" numlines=\"1\" declaredvars=\"player\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"327\" y=\"0\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.jump();\" numlines=\"1\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"0\" y=\"173\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.jump();\" numlines=\"1\"></mutation></block></statement></block><block type=\"device_forever\" x=\"306"],[1,"/block><block type=\"device_forever\" x=\"208"],[0,"\" y=\"1"],[-1,"73"],[0,"\"></"]],"start1":114,"start2":114,"length1":799,"length2":56}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"();\n"],[-1,"let obstacle = new Obstacle();"],[0,"\n\n\ni"]],"start1":23,"start2":23,"length1":38,"length2":8},{"diffs":[[0,"ton."],[-1,"A, () => {\n    obstacle.spawn(); // Mostra o obstáculo na tela"],[1,"B, function () {\n    player.jump();"],[0,"\n});"]],"start1":55,"start2":55,"length1":70,"length2":43},{"diffs":[[0,"nPressed(Button."],[-1,"B"],[1,"A"],[0,", function () {\n"]],"start1":113,"start2":113,"length1":33,"length2":33},{"diffs":[[0,"mp();\n})"],[1,";"],[0,"\n\nbasic."]],"start1":159,"start2":159,"length1":16,"length2":17},{"diffs":[[0,") {\n"],[-1,"\t"],[0,"\n})"],[-1,"\n"]],"start1":194,"start2":194,"length1":9,"length2":7}]},{"type":"edited","filename":"obstacle.ts","patch":[{"diffs":[[-1,"class Obstacle {\n    private sprite: Sprite; // Sprite do obstáculo\n    private isActive: boolean; // Indica se o obstáculo está ativo na tela\n\n    constructor() {\n        // Cria o sprite do obstáculo, inicialmente invisível\n        this.sprite = game.createSprite(4, 4); // Posição inicial (4, 4)\n        this.sprite.setBrightness(0); // Inicialmente invisível\n        this.isActive = false; // Obstáculo começa inativo\n    }\n\n    // Método para ativar o obstáculo na posição inicial (4, 4)\n    public spawn(): void {\n        if (!this.isActive) { // Só ativa se o obstáculo não estiver ativo\n            this.sprite.setX(4); // Posição X inicial\n            this.sprite.setY(4); // Posição Y fixa\n            this.sprite.setBrightness(255); // Torna o obstáculo visível\n            this.isActive = true; // Marca o obstáculo como ativo\n        }\n    }\n\n    // Método para mover o obstáculo para a esquerda\n    public move(): void {\n        if (this.isActive) { // Só move se o obstáculo estiver ativo\n            const currentX = this.sprite.x(); // Pega a posição X atual\n            if (currentX > 0) { // Se não chegou ao fim (0, 4)\n                this.sprite.setX(currentX - 1); // Move para a esquerda\n            } else { // Se chegou ao fim (0, 4)\n                this.despawn(); // Remove o obstáculo\n            }\n        }\n    }\n\n    // Método para remover o obstáculo da tela\n    public despawn(): void {\n        this.sprite.setBrightness(0); // Torna o obstáculo invisível\n        this.isActive = false; // Marca o obstáculo como inativo\n    }\n\n    // Método para verificar se o obstáculo está ativo\n    public isActiveObs(): boolean {\n        return this.isActive;\n    }\n}"],[1,"// Adicione seu código aqui\n"]],"start1":0,"start2":0,"length1":1689,"length2":28}]}]},{"timestamp":1740231554401,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"if (!obstacle.isActiveObs()) { // Só ativa o obstáculo se ele não estiver ativo\n        obstacle.spawn(); // Mostra o obstáculo na posição inicial (4, 4)\n    } else {\n        obstacle.move(); // Move o obstáculo para a esquerda\n    }"],[1,"obstacle.spawn(); // Mostra o obstáculo na tela"],[0,"\n});"]],"start1":100,"start2":100,"length1":241,"length2":55}]}]},{"timestamp":1740232100659,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"cle();\n\n"],[1,"\n"],[0,"input.on"]],"start1":51,"start2":51,"length1":16,"length2":17},{"diffs":[[0,"ton."],[-1,"B, function () {\n    player.jump();\n})\n\nbasic.forever(function () {\n    basic.pause(200)"],[1,"A, () => {"],[0,"\n   "]],"start1":85,"start2":85,"length1":96,"length2":18},{"diffs":[[0,"a\n    }\n"],[1,"});\n\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n})\n\nbasic.forever(function () {\n\t\n"],[0,"})\n"]],"start1":330,"start2":330,"length1":11,"length2":115}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"   basic.pause(1"],[-1,"5"],[1,"0"],[0,"0);\n\n           "]],"start1":591,"start2":591,"length1":33,"length2":33},{"diffs":[[0,"   basic.pause(1"],[-1,"5"],[1,"0"],[0,"0);\n\n           "]],"start1":656,"start2":656,"length1":33,"length2":33},{"diffs":[[0,"se(1"],[-1,"5"],[1,"0"],[0,"0);\n"]],"start1":733,"start2":733,"length1":9,"length2":9}]},{"type":"edited","filename":"obstacle.ts","patch":[{"diffs":[[0,"ess("],[-1,"100"],[1,"255"],[0,"); /"]],"start1":734,"start2":734,"length1":11,"length2":11},{"diffs":[[0,"}\n    }\n"],[-1,"    "],[0,"\n    // "]],"start1":847,"start2":847,"length1":20,"length2":16},{"diffs":[[0,"ite."],[-1,"move(-"],[1,"setX(currentX - "],[0,"1); "]],"start1":1163,"start2":1163,"length1":14,"length2":24}]}]},{"timestamp":1740232631514,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ME.md\",\n"],[1,"        \"createsprite.ts\",\n"],[0,"        "]],"start1":213,"start2":213,"length1":16,"length2":43}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"te: "],[-1,"game.Led"],[0,"Spri"]],"start1":31,"start2":31,"length1":16,"length2":8},{"diffs":[[0,"   }"],[-1,"\n\n    live(): void {\n        let colission\n    }"],[0,"\n}\n"]],"start1":946,"start2":946,"length1":55,"length2":7}]},{"type":"edited","filename":"obstacle.ts","patch":[{"diffs":[[0,"te: "],[-1,"game.Led"],[0,"Spri"]],"start1":33,"start2":33,"length1":16,"length2":8},{"diffs":[[0,"        }\n    }\n"],[1,"    "],[0,"\n    // Método p"]],"start1":839,"start2":839,"length1":32,"length2":36}]},{"type":"removed","filename":"createsprite.ts","value":"type Sprite = game.LedSprite\n\nclass CreateSprite {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.createSprite(x, y));\n    }\n}"}]},{"timestamp":1740233218963,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,");\n\n"],[-1,"player.live()\n\n"],[0,"inpu"]],"start1":55,"start2":55,"length1":23,"length2":8},{"diffs":[[0,"() {"],[-1,"\n\n    game.isGameOver()\n    "],[0,"\n   "]],"start1":151,"start2":151,"length1":36,"length2":8}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0," col"],[-1,"l"],[0,"is"],[1,"s"],[0,"ion"],[-1," = 3; // Variável que armazena o tipo de colisão\n        let live\n\n        switch (collision) {\n            case 0:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                live = game.createSprite(2, 0);\n                break;\n            case 1:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                break;\n            case 2:\n                live = game.createSprite(0, 0);\n                break;\n            case 3:\n                game.isGameOver()\n                break;\n        }"],[0,"\n   "]],"start1":990,"start2":990,"length1":613,"length2":14}]}]},{"timestamp":1740233674962,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"2"],[0,"0\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":104,"start2":104,"length1":16,"length2":14},{"diffs":[[0,"on><"],[-1,"next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let obstacle = new Obstacle();\" numlines=\"1\" declaredvars=\"obstacle\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.live()\" numlines=\"1\"></mutation></block></next></block></next><"],[0,"/blo"]],"start1":303,"start2":303,"length1":347,"length2":8},{"diffs":[[0,"x=\"3"],[-1,"86"],[1,"27"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":368,"start2":368,"length1":16,"length2":15},{"diffs":[[0,"ice_"],[-1,"forever\" x=\"692\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"game.isGameOver()\" numlines=\"1\"></mutation><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">200</field></shadow></value><next><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_negate\"><value name=\"BOOL\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">obstacle.isActiveObs()</field></block></value></block></value"],[1,"button_event\" x=\"0\" y=\"173\"><field name=\"NAME\">Button.A</field"],[0,"><st"]],"start1":616,"start2":616,"length1":700,"length2":70},{"diffs":[[0,"me=\""],[-1,"DO0"],[1,"HANDLER"],[0,"\"><b"]],"start1":696,"start2":696,"length1":11,"length2":15},{"diffs":[[0,"e0=\""],[-1,"obstacle.spawn"],[1,"player.jump"],[0,"();\""]],"start1":794,"start2":794,"length1":22,"length2":19},{"diffs":[[0,"on><"],[-1,"comment pinned=\"false\" h=\"80\" w=\"160\">Mostra o obstáculo na posição inicial (4, 4)</comment></block></statement><statement name=\"ELSE\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"obstacle.move();\" numlines=\"1\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Move o obstáculo para a esquerda</comment></block></statement></block></next></block></next></block></statement"],[1,"/block></statement></block><block type=\"device_forever\" x=\"306\" y=\"173\""],[0,"></b"]],"start1":835,"start2":835,"length1":424,"length2":79}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"nction () {\n"],[1,"\n"],[0,"    game.isG"]],"start1":159,"start2":159,"length1":24,"length2":25},{"diffs":[[0,"se(200)\n"],[-1,"    "],[0,"    if ("]],"start1":212,"start2":212,"length1":20,"length2":16},{"diffs":[[0,"   if (!"],[-1,"("],[0,"obstacle"]],"start1":221,"start2":221,"length1":17,"length2":16},{"diffs":[[0,"s())"],[-1,")"],[0," {"],[-1,"\n           "],[1," // Só ativa o obstáculo se ele não estiver ativo\n        obstacle.spawn();"],[0," // "]],"start1":248,"start2":248,"length1":23,"length2":85},{"diffs":[[0," (4, 4)\n    "],[1,"} else {\n"],[0,"        obst"]],"start1":370,"start2":370,"length1":24,"length2":33},{"diffs":[[0,"cle."],[-1,"spawn();\n        } else {\n           "],[1,"move();"],[0," // "]],"start1":404,"start2":404,"length1":45,"length2":15},{"diffs":[[0,"da\n "],[-1,"           obstacle.move();\n"],[0,"   }"]],"start1":449,"start2":449,"length1":36,"length2":8}]}]},{"timestamp":1740233981435,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"nction () {\n"],[1,"    game.isGameOver()\n"],[0,"    \n    bas"]],"start1":159,"start2":159,"length1":24,"length2":46}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"e;\n    p"],[-1,"rivate"],[1,"ublic"],[0," isJumpi"]],"start1":48,"start2":48,"length1":22,"length2":21},{"diffs":[[0,"se;\n"],[-1,"    private collision: number = 0;\n    private obstacle: Obstacle;"],[0,"\n\n  "]],"start1":86,"start2":86,"length1":74,"length2":8},{"diffs":[[0," live(): void {\n"],[1,"        let collision = 3; // Variável que armazena o tipo de colisão\n"],[0,"        let live"]],"start1":963,"start2":963,"length1":32,"length2":102},{"diffs":[[0,"   game."],[-1,"g"],[1,"isG"],[0,"ameOver("]],"start1":1546,"start2":1546,"length1":17,"length2":19},{"diffs":[[0,"   }"],[-1,"\n\n    collisionDetect(): void {\n        if(obstacle) {\n\n        }\n    }"],[0,"\n}\n"]],"start1":1601,"start2":1601,"length1":78,"length2":7}]}]},{"timestamp":1740234617784,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"cle:"],[-1," new"],[0," Obs"]],"start1":143,"start2":143,"length1":12,"length2":8}]}]},{"timestamp":1740234625728,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"ber = 0;"],[1,"\n    private obstacle: new Obstacle;"],[0,"\n\n    co"]],"start1":117,"start2":117,"length1":16,"length2":52},{"diffs":[[0,"switch ("],[-1,"this."],[0,"collisio"]],"start1":1076,"start2":1076,"length1":21,"length2":16},{"diffs":[[0,"    "],[-1,"let obstacle = new Obstacle();\n\n        if(obstacle.getSpriteX == 1"],[1,"if(obstacle"],[0,") {\n"]],"start1":1640,"start2":1640,"length1":75,"length2":19}]},{"type":"edited","filename":"obstacle.ts","patch":[{"diffs":[[0,"tela"],[-1,"\n    private xPos: number = 4;"],[0,"\n\n  "]],"start1":146,"start2":146,"length1":38,"length2":8},{"diffs":[[0,"   }"],[-1,"\n\n    public getSpriteX(): number {\n        return this.sprite.x;\n    }"],[0,"\n}"]],"start1":1681,"start2":1681,"length1":77,"length2":6}]}]},{"timestamp":1740235073793,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"obstacle.ts","patch":[{"diffs":[[0,"= 4;"],[-1," // Armazena a posição X do obstáculo"],[0,"\n"],[1,""],[0,"\n   "]],"start1":176,"start2":176,"length1":46,"length2":9},{"diffs":[[0,"ivo\n"],[-1,"            this.xPos = 4; // Reseta a posição X\n"],[0,"    "]],"start1":629,"start2":629,"length1":57,"length2":8},{"diffs":[[0,"etX("],[-1,"this.xPos); // Define a p"],[1,"4); // P"],[0,"osiç"]],"start1":658,"start2":658,"length1":33,"length2":16},{"diffs":[[0," // "],[-1,"Define a p"],[1,"P"],[0,"osiç"]],"start1":719,"start2":719,"length1":18,"length2":9},{"diffs":[[0,"    "],[-1,"if (this.xPos > 0) { // Se não chegou ao fim (0, 4)\n                this.xPos -= 1; // Atualiza a posição X\n                this.sprite.setX(this.xPos); // Move o sprit"],[1,"const currentX = this.sprite.x(); // Pega a posição X atual\n            if (currentX > 0) { // Se não chegou ao fim (0, 4)\n                this.sprite.move(-1); // Mov"],[0,"e pa"]],"start1":1050,"start2":1050,"length1":176,"length2":175},{"diffs":[[0,"umber {\n"],[1,""],[0,"        "]],"start1":1743,"start2":1743,"length1":16,"length2":16},{"diffs":[[0,"sprite.x"],[-1,"()"],[0,";\n    }\n"]],"start1":1771,"start2":1771,"length1":18,"length2":16}]}]},{"timestamp":1740235644326,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n\nplayer"],[1,".live"],[0,"()\n\ninpu"]],"start1":57,"start2":57,"length1":16,"length2":21},{"diffs":[[0,"();\n})\n\n"],[-1,"\n"],[0,"basic.fo"]],"start1":135,"start2":135,"length1":17,"length2":16},{"diffs":[[0,"on () {\n"],[1,"    "],[0,"\n    bas"]],"start1":163,"start2":163,"length1":16,"length2":20}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"les\": [\n"],[1,"        \"main.blocks\",\n"],[0,"        "]],"start1":150,"start2":150,"length1":16,"length2":39}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"= 0;"],[-1,"\n    private lives: game.LedSprite[] = []; // Array para armazenar os sprites de vida"],[0,"\n\n  "]],"start1":121,"start2":121,"length1":93,"length2":8},{"diffs":[[0,"nicial ("],[-1,"1, 4"],[1,"0, 0"],[0,")\n      "]],"start1":185,"start2":185,"length1":20,"length2":20},{"diffs":[[0,"4);\n"],[-1,"        this.initializeLives(); // Inicializa as vidas\n    }\n\n    // Método para inicializar as vidas\n    private initializeLives(): void {\n        for (let i = 0; i < 3; i++) {\n            this.lives.push(game.createSprite(i, 0)); // Cria um sprite de vida na posição (i, 0)\n        }\n"],[0,"    "]],"start1":242,"start2":242,"length1":294,"length2":8},{"diffs":[[0," }\n\n"],[-1,"    // Método para fazer o jogador pular\n"],[0,"    "]],"start1":369,"start2":369,"length1":49,"length2":8},{"diffs":[[0,"setPosition(3);\n"],[1,"\n"],[0,"            basi"]],"start1":608,"start2":608,"length1":32,"length2":33},{"diffs":[[0,"ion(2);\n"],[1,"\n"],[0,"        "]],"start1":681,"start2":681,"length1":16,"length2":17},{"diffs":[[0,"ion(3);\n"],[1,"\n"],[0,"        "]],"start1":746,"start2":746,"length1":16,"length2":17},{"diffs":[[0,"osition(4);\n"],[1,"\n"],[0,"            "]],"start1":858,"start2":858,"length1":24,"length2":25},{"diffs":[[0,"use(200)"],[-1,";"],[0,"\n\n      "]],"start1":891,"start2":891,"length1":17,"length2":16},{"diffs":[[0,"terminou"],[1,"            "],[0,"\n       "]],"start1":957,"start2":957,"length1":16,"length2":28},{"diffs":[[0,"    "],[-1,"// Método para verificar colisões e atualizar vidas\n    public checkCollision(obstacle: Obstacle): void {\n        if (obstacle.getSpriteX() === 1 && this.sprite.get(LedSpriteProperty.Y) === 4) {\n            this.collision += 1; // Incrementa o contador de colisões\n            this.updateLives(); // Atualiza as vidas"],[1,"live(): void {\n        let live\n\n        switch (this.collision) {\n            case 0:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                live = game.createSprite(2, 0);\n                break;"],[0,"\n   "]],"start1":995,"start2":995,"length1":325,"length2":261},{"diffs":[[0,"    "],[-1,"}\n"],[0,"    "],[-1,"}\n\n    // Método para atualizar as vidas\n    private updateLives(): void {\n        if (this.collision <= this.lives.length) {\n            // Remove uma vida\n            let life = this.lives.pop();\n            if (life) {\n                life.delete(); // Remove o sprite da vida\n"],[1,"case 1:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                break;\n            case 2:\n                live = game.createSprite(0, 0);\n                break;\n            case 3:\n                game.gameOver()\n    "],[0,"    "]],"start1":1257,"start2":1257,"length1":294,"length2":286},{"diffs":[[0,"            "],[-1,"}"],[1,"break;"],[0,"\n        }\n\n"]],"start1":1539,"start2":1539,"length1":25,"length2":30},{"diffs":[[0,"  }\n"],[-1,"\n"],[0,"    "],[1,"}\n\n"],[0,"    "],[-1,"// Verifica se o jogador perdeu todas as"],[1,"collisionDetect():"],[0," v"],[1,"o"],[0,"id"],[-1,"as"],[1," {"],[0,"\n   "]],"start1":1564,"start2":1564,"length1":63,"length2":44},{"diffs":[[0,"    "],[-1,"if (this.collision >= 3) {\n            game.gameOver(); // Fim de jogo"],[1,"let obstacle = new Obstacle();\n\n        if(obstacle.getSpriteX == 1) {\n"],[0,"\n   "]],"start1":1609,"start2":1609,"length1":78,"length2":79},{"diffs":[[0,"\n    }\n}"],[1,"\n"]],"start1":1694,"start2":1694,"length1":8,"length2":9}]},{"type":"edited","filename":"obstacle.ts","patch":[{"diffs":[[0," na tela"],[1,"\n    private xPos: number = 4; // Armazena a posição X do obstáculo"],[0,"\n\n    co"]],"start1":142,"start2":142,"length1":16,"length2":83},{"diffs":[[0,"o estiver ativo\n"],[1,"            this.xPos = 4; // Reseta a posição X\n"],[0,"            this"]],"start1":654,"start2":654,"length1":32,"length2":81},{"diffs":[[0,"te.setX("],[-1,"4); // P"],[1,"this.xPos); // Define a p"],[0,"osição X"]],"start1":740,"start2":740,"length1":24,"length2":41},{"diffs":[[0,"setY(4); // "],[-1,"P"],[1,"Define a p"],[0,"osição Y fix"]],"start1":814,"start2":814,"length1":25,"length2":34},{"diffs":[[0,"    "],[-1,"const currentX = this.sprite.x(); // Pega a posição X atual\n            if (currentX > 0) { // Se não chegou ao fim (0, 4)\n                this.sprite.move(-1); // Mov"],[1,"if (this.xPos > 0) { // Se não chegou ao fim (0, 4)\n                this.xPos -= 1; // Atualiza a posição X\n                this.sprite.setX(this.xPos); // Move o sprit"],[0,"e pa"]],"start1":1162,"start2":1162,"length1":175,"length2":176}]},{"type":"removed","filename":"main.blocks","value":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let player = new Player();\" numlines=\"1\" declaredvars=\"player\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let obstacle = new Obstacle();\" numlines=\"1\" declaredvars=\"obstacle\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.live()\" numlines=\"1\"></mutation></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"386\" y=\"20\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.jump();\" numlines=\"1\"></mutation></block></statement></block><block type=\"device_forever\" x=\"692\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"game.isGameOver()\" numlines=\"1\"></mutation><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">200</field></shadow></value><next><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_negate\"><value name=\"BOOL\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">obstacle.isActiveObs()</field></block></value></block></value><statement name=\"DO0\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"obstacle.spawn();\" numlines=\"1\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Mostra o obstáculo na posição inicial (4, 4)</comment></block></statement><statement name=\"ELSE\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"obstacle.move();\" numlines=\"1\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Move o obstáculo para a esquerda</comment></block></statement></block></next></block></next></block></statement></block></xml>"}]},{"timestamp":1740236237196,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"cle();\n\n"],[1,"player()\n\n"],[0,"input.on"]],"start1":51,"start2":51,"length1":16,"length2":26},{"diffs":[[0,"();\n})\n\n"],[1,"\n"],[0,"basic.fo"]],"start1":130,"start2":130,"length1":16,"length2":17},{"diffs":[[0," {\n\n"],[-1,"    player.checkCollision(obstacle);\n\n"],[0,"    "]],"start1":164,"start2":164,"length1":46,"length2":8}]}]},{"timestamp":1740236888158,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"das\n"],[-1,"        game\n"],[0,"    "]],"start1":382,"start2":382,"length1":21,"length2":8}]}]},{"timestamp":1740236893017,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"();\n})\n\n"],[-1,"\n"],[0,"basic.fo"]],"start1":120,"start2":120,"length1":17,"length2":16},{"diffs":[[0,");\n\n"],[-1,"    \n    \n"],[0,"    "]],"start1":191,"start2":191,"length1":18,"length2":8}]},{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"za as vidas\n"],[1,"        game\n"],[0,"    }\n\n    /"]],"start1":374,"start2":374,"length1":24,"length2":37}]}]},{"timestamp":1740237132676,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"das\n"],[-1,"            game.\n"],[0,"    "]],"start1":1710,"start2":1710,"length1":26,"length2":8}]}]},{"timestamp":1740237958290,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"ame."],[-1,"addScore"],[0,"\n   "]],"start1":1727,"start2":1727,"length1":16,"length2":8}]}]},{"timestamp":1740237959498,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"player.ts","patch":[{"diffs":[[0,"vida"],[-1,"\n    private score: number = 0;"],[0,"\n\n  "]],"start1":206,"start2":206,"length1":39,"length2":8},{"diffs":[[0,"    "],[-1,"}"],[0," "],[1,"   game.addScore\n        }"],[0,"\n   "]],"start1":1718,"start2":1718,"length1":10,"length2":35}]}]},{"timestamp":1740238460450,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e();"],[-1,"\nlet score = 0;"],[0,"\n\nin"]],"start1":53,"start2":53,"length1":23,"length2":8},{"diffs":[[0,"    "],[-1,"score ++;"],[0,"\n   "]],"start1":196,"start2":196,"length1":17,"length2":8}]}]},{"timestamp":1740239058571,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"})\n\n"],[-1,"input.onButtonPressed(Button.B, function () {\n    player.jump();\n})\n"],[0,"\nbas"]],"start1":139,"start2":139,"length1":76,"length2":8},{"diffs":[[0,"++;\n"],[-1,"\n"],[0,"    "],[-1,"if (game.isGameOver) {\n        game.setScore(score)\n    }\n"],[0,"\n   "]],"start1":221,"start2":221,"length1":71,"length2":12}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,": \"t"],[-1,"-rex game"],[1,"est"],[0,"\",\n "]],"start1":12,"start2":12,"length1":17,"length2":11}]}]},{"timestamp":1740239753346,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":250,"start2":250,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// testes vão aqui; isto não será compilado quando este pacote for usado como uma extensão.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1740222959866,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1740224760147,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"208\" y=\"1\"></block></xml>","main.ts":"basic.forever(function () {\n    \n    \n})\n\ntype Sprite = game.LedSprite(0,0); // Substitua 'any' pelo tipo real do sprite, se disponível\n\nclass Player {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.createSprite(x, y));\n    }\n}\n\n// Cria uma instância da classe Player\nlet playerLive = new Player();","README.md":"","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1740226570510,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"208\" y=\"1\"></block></xml>","main.ts":"let player = new Player();\n\n\n\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n});\n\nbasic.forever(function () {\n\n    \n})","README.md":"","createsprite.ts":"type Sprite = game.LedSprite\n\nclass CreateSprite {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.createSprite(x, y));\n    }\n}","player.ts":"class Player {\n    private sprite: Sprite;\n    private isJumping: boolean = false;\n\n    constructor() {\n        // Cria um sprite na posição inicial (0, 0)\n        this.sprite = game.createSprite(1, 4);\n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    jump(): void {\n        if (!this.isJumping) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            this.setPosition(2);\n\n            basic.pause(100);\n\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            this.isJumping = false; // Marca que o pulo terminou\n        }\n    }\n}\n","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"machine-learning\": \"github:microbit-foundation/pxt-microbit-ml#v1.0.10\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"createsprite.ts\",\n        \"player.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1740228371372,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"208\" y=\"1\"></block></xml>","main.ts":"let player = new Player();\n\n\n\ninput.onButtonPressed(Button.B, function () {\n    if(player.isJumping === false){\n        player.jump();\n    }\n});\n\nbasic.forever(function () {\n\n    \n    \n})","README.md":"","createsprite.ts":"type Sprite = game.LedSprite\n\nclass CreateSprite {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.createSprite(x, y));\n    }\n}","player.ts":"class Player {\n    private sprite: Sprite;\n    public isJumping: boolean = false;\n    private strip: neopixel.Strip;\n\n    constructor() {\n        // Cria um sprite na posição inicial (0, 0)\n        this.sprite = game.createSprite(1, 4);\n        \n        // Inicializa a fita de LEDs NeoPixel\n        this.strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB_RGB);\n\n        // Define uma cor para o jogador (no formato RGB)\n        this.(neopixel.rgb(0, 255, 255)); // Ciano (R=0, G=255, B=255)\n        \n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    // Método para aplicar a cor ao NeoPixel\n    private applyColor(): void {\n        // Aqui você pode usar a biblioteca NeoPixel para definir a cor do LED\n        // Exemplo: neopixel.setPixelColor(0, this.color); // Define a cor do primeiro LED\n        // Nota: O método exato depende da biblioteca que você está usando.\n        // Substitua pelo método correto da sua biblioteca.\n        neopixel.create(0, this.color); // Exemplo hipotético\n        neopixel.show(); // Atualiza o LED com a nova cor\n    }\n\n    jump(): void {\n        if (this.isJumping === false) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            this.setPosition(2);\n\n            basic.pause(100);\n\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            basic.pause(200)\n\n            this.isJumping = false; // Marca que o pulo terminou            \n        }\n    }\n}\n","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"neopixel\": \"github:microsoft/pxt-neopixel#v0.7.6\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"createsprite.ts\",\n        \"player.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1740230395972,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"208\" y=\"1\"></block></xml>","main.ts":"let player = new Player();\n\n\n\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n});\n\ninput.onButtonPressed(Button.A, function () {\n    player.jump();\n});\n\nbasic.forever(function () {\n\n})","README.md":"","createsprite.ts":"type Sprite = game.LedSprite\n\nclass CreateSprite {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.createSprite(x, y));\n    }\n}","player.ts":"class Player {\n    private sprite: Sprite;\n    public isJumping: boolean = false;\n\n\n    constructor() {\n        // Cria um sprite na posição inicial (0, 0)\n        this.sprite = game.createSprite(1, 4);\n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    jump(): void {\n        if (this.isJumping === false) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            this.setPosition(2);\n\n            basic.pause(100);\n\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            basic.pause(200)\n\n            this.isJumping = false; // Marca que o pulo terminou            \n        }\n    }\n}\n","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"createsprite.ts\",\n        \"player.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1740232197363,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let player = new Player();\" numlines=\"1\" declaredvars=\"player\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"327\" y=\"0\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.jump();\" numlines=\"1\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"0\" y=\"173\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.jump();\" numlines=\"1\"></mutation></block></statement></block><block type=\"device_forever\" x=\"306\" y=\"173\"></block></xml>","main.ts":"let player = new Player();\nlet obstacle = new Obstacle();\n\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n})\n\nbasic.forever(function () {\n    basic.pause()\n    if (!obstacle.isActiveObs()) { // Só ativa o obstáculo se ele não estiver ativo\n        obstacle.spawn(); // Mostra o obstáculo na posição inicial (4, 4)\n    } else {\n        obstacle.move(); // Move o obstáculo para a esquerda\n    }\n})\n","README.md":"","createsprite.ts":"type Sprite = game.LedSprite\n\nclass CreateSprite {\n    // Declara a propriedade 'sprites' como um array de Sprite\n    sprites: Sprite[];\n\n    constructor() {\n        // Inicializa a propriedade 'sprites' como um array vazio\n        this.sprites = [];\n    }\n\n    // Método para adicionar um sprite\n    addSprite(x: number, y: number): void {\n        this.sprites.push(game.createSprite(x, y));\n    }\n}","player.ts":"class Player {\n    private sprite: Sprite;\n    public isJumping: boolean = false;\n\n\n    constructor() {\n        // Cria um sprite na posição inicial (0, 0)\n        this.sprite = game.createSprite(1, 4);\n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    jump(): void {\n        if (this.isJumping === false) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            this.setPosition(2);\n\n            basic.pause(100);\n\n            this.setPosition(3);\n\n            basic.pause(100);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            basic.pause(200)\n\n            this.isJumping = false; // Marca que o pulo terminou            \n        }\n    }\n}\n","obstacle.ts":"class Obstacle {\n    private sprite: Sprite; // Sprite do obstáculo\n    private isActive: boolean; // Indica se o obstáculo está ativo na tela\n\n    constructor() {\n        // Cria o sprite do obstáculo, inicialmente invisível\n        this.sprite = game.createSprite(4, 4); // Posição inicial (4, 4)\n        this.sprite.setBrightness(0); // Inicialmente invisível\n        this.isActive = false; // Obstáculo começa inativo\n    }\n\n    // Método para ativar o obstáculo na posição inicial (4, 4)\n    public spawn(): void {\n        if (!this.isActive) { // Só ativa se o obstáculo não estiver ativo\n            this.sprite.setX(4); // Posição X inicial\n            this.sprite.setY(4); // Posição Y fixa\n            this.sprite.setBrightness(255); // Torna o obstáculo visível\n            this.isActive = true; // Marca o obstáculo como ativo\n        }\n    }\n\n    // Método para mover o obstáculo para a esquerda\n    public move(): void {\n        if (this.isActive) { // Só move se o obstáculo estiver ativo\n            const currentX = this.sprite.x(); // Pega a posição X atual\n            if (currentX > 0) { // Se não chegou ao fim (0, 4)\n                this.sprite.setX(currentX - 1); // Move para a esquerda\n            } else { // Se chegou ao fim (0, 4)\n                this.despawn(); // Remove o obstáculo\n            }\n        }\n    }\n\n    // Método para remover o obstáculo da tela\n    public despawn(): void {\n        this.sprite.setBrightness(0); // Torna o obstáculo invisível\n        this.isActive = false; // Marca o obstáculo como inativo\n    }\n\n    // Método para verificar se o obstáculo está ativo\n    public isActiveObs(): boolean {\n        return this.isActive;\n    }\n}","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"createsprite.ts\",\n        \"player.ts\",\n        \"obstacle.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1740234367343,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let player = new Player();\" numlines=\"1\" declaredvars=\"player\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let obstacle = new Obstacle();\" numlines=\"1\" declaredvars=\"obstacle\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.live()\" numlines=\"1\"></mutation></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"386\" y=\"20\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"player.jump();\" numlines=\"1\"></mutation></block></statement></block><block type=\"device_forever\" x=\"692\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"game.isGameOver()\" numlines=\"1\"></mutation><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">200</field></shadow></value><next><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_negate\"><value name=\"BOOL\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">obstacle.isActiveObs()</field></block></value></block></value><statement name=\"DO0\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"obstacle.spawn();\" numlines=\"1\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Mostra o obstáculo na posição inicial (4, 4)</comment></block></statement><statement name=\"ELSE\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"obstacle.move();\" numlines=\"1\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Move o obstáculo para a esquerda</comment></block></statement></block></next></block></next></block></statement></block></xml>","main.ts":"let player = new Player();\nlet obstacle = new Obstacle();\n\nplayer.live()\n\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n})\n\nbasic.forever(function () {\n    game.isGameOver()\n    \n    basic.pause(200)\n        if (!(obstacle.isActiveObs())) {\n            // Mostra o obstáculo na posição inicial (4, 4)\n            obstacle.spawn();\n        } else {\n            // Move o obstáculo para a esquerda\n            obstacle.move();\n   }\n})\n","README.md":"","player.ts":"class Player {\n    private sprite: game.LedSprite;\n    public isJumping: boolean = false;\n\n\n    constructor() {\n        // Cria um sprite na posição inicial (0, 0)\n        this.sprite = game.createSprite(1, 4);\n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    jump(): void {\n        if (this.isJumping === false) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n\n            basic.pause(150);\n\n            this.setPosition(2);\n\n            basic.pause(150);\n\n            this.setPosition(3);\n\n            basic.pause(150);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            basic.pause(200)\n\n            this.isJumping = false; // Marca que o pulo terminou            \n        }\n    }\n\n    live(): void {\n        let collision = 3; // Variável que armazena o tipo de colisão\n        let live\n\n        switch (collision) {\n            case 0:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                live = game.createSprite(2, 0);\n                break;\n            case 1:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                break;\n            case 2:\n                live = game.createSprite(0, 0);\n                break;\n            case 3:\n                game.isGameOver()\n                break;\n        }\n    }\n}\n","obstacle.ts":"class Obstacle {\n    private sprite: game.LedSprite; // Sprite do obstáculo\n    private isActive: boolean; // Indica se o obstáculo está ativo na tela\n\n    constructor() {\n        // Cria o sprite do obstáculo, inicialmente invisível\n        this.sprite = game.createSprite(4, 4); // Posição inicial (4, 4)\n        this.sprite.setBrightness(0); // Inicialmente invisível\n        this.isActive = false; // Obstáculo começa inativo\n    }\n\n    // Método para ativar o obstáculo na posição inicial (4, 4)\n    public spawn(): void {\n        if (!this.isActive) { // Só ativa se o obstáculo não estiver ativo\n            this.sprite.setX(4); // Posição X inicial\n            this.sprite.setY(4); // Posição Y fixa\n            this.sprite.setBrightness(100); // Torna o obstáculo visível\n            this.isActive = true; // Marca o obstáculo como ativo\n        }\n    }\n\n    // Método para mover o obstáculo para a esquerda\n    public move(): void {\n        if (this.isActive) { // Só move se o obstáculo estiver ativo\n            const currentX = this.sprite.x(); // Pega a posição X atual\n            if (currentX > 0) { // Se não chegou ao fim (0, 4)\n                this.sprite.move(-1); // Move para a esquerda\n            } else { // Se chegou ao fim (0, 4)\n                this.despawn(); // Remove o obstáculo\n            }\n        }\n    }\n\n    // Método para remover o obstáculo da tela\n    public despawn(): void {\n        this.sprite.setBrightness(0); // Torna o obstáculo invisível\n        this.isActive = false; // Marca o obstáculo como inativo\n    }\n\n    // Método para verificar se o obstáculo está ativo\n    public isActiveObs(): boolean {\n        return this.isActive;\n    }\n}","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"player.ts\",\n        \"obstacle.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1740236218553,"editorVersion":"7.0.57","text":{"main.ts":"let player = new Player();\nlet obstacle = new Obstacle();\n\nplayer.live()\n\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n})\n\n\nbasic.forever(function () {\n\n    basic.pause(200)\n        if (!(obstacle.isActiveObs())) {\n            // Mostra o obstáculo na posição inicial (4, 4)\n            obstacle.spawn();\n        } else {\n            // Move o obstáculo para a esquerda\n            obstacle.move();\n   }\n})\n","README.md":"","player.ts":"class Player {\n    private sprite: game.LedSprite;\n    private isJumping: boolean = false;\n    private collision: number = 0;\n\n    constructor() {\n        // Cria um sprite na posição inicial (0, 0)\n        this.sprite = game.createSprite(1, 4);\n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    jump(): void {\n        if (this.isJumping === false) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n\n            basic.pause(150);\n\n            this.setPosition(2);\n\n            basic.pause(150);\n\n            this.setPosition(3);\n\n            basic.pause(150);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n\n            basic.pause(200)\n\n            this.isJumping = false; // Marca que o pulo terminou            \n        }\n    }\n\n    live(): void {\n        let live\n\n        if (Obstacle.getSpriteX() === 1) {\n            this.collision + 1;\n        }\n\n        switch (this.collision) {\n            case 0:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                live = game.createSprite(2, 0);\n                break;\n            case 1:\n                live = game.createSprite(0, 0);\n                live = game.createSprite(1, 0);\n                break;\n            case 2:\n                live = game.createSprite(0, 0);\n                break;\n            case 3:\n                game.gameOver()\n                break;\n        }\n    }\n}\n","obstacle.ts":"class Obstacle {\n    private sprite: game.LedSprite; // Sprite do obstáculo\n    private isActive: boolean; // Indica se o obstáculo está ativo na tela\n\n    constructor() {\n        // Cria o sprite do obstáculo, inicialmente invisível\n        this.sprite = game.createSprite(4, 4); // Posição inicial (4, 4)\n        this.sprite.setBrightness(0); // Inicialmente invisível\n        this.isActive = false; // Obstáculo começa inativo\n    }\n\n    // Método para ativar o obstáculo na posição inicial (4, 4)\n    public spawn(): void {\n        if (!this.isActive) { // Só ativa se o obstáculo não estiver ativo\n            this.sprite.setX(4); // Posição X inicial\n            this.sprite.setY(4); // Posição Y fixa\n            this.sprite.setBrightness(100); // Torna o obstáculo visível\n            this.isActive = true; // Marca o obstáculo como ativo\n        }\n    }\n\n    // Método para mover o obstáculo para a esquerda\n    public move(): void {\n        if (this.isActive) { // Só move se o obstáculo estiver ativo\n            const currentX = this.sprite.x(); // Pega a posição X atual\n            if (currentX > 0) { // Se não chegou ao fim (0, 4)\n                this.sprite.move(-1); // Move para a esquerda\n            } else { // Se chegou ao fim (0, 4)\n                this.despawn(); // Remove o obstáculo\n            }\n        }\n    }\n\n    // Método para remover o obstáculo da tela\n    public despawn(): void {\n        this.sprite.setBrightness(0); // Torna o obstáculo invisível\n        this.isActive = false; // Marca o obstáculo como inativo\n    }\n\n    // Método para verificar se o obstáculo está ativo\n    public isActiveObs(): boolean {\n        return this.isActive;\n    }\n\n    public getSpriteX(): number {\n        return this.sprite.x();\n    }\n}","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"player.ts\",\n        \"obstacle.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1740238025590,"editorVersion":"7.0.57","text":{"main.ts":"let player = new Player();\nlet obstacle = new Obstacle();\n\ninput.onButtonPressed(Button.B, function () {\n    player.jump();\n})\n\n\nbasic.forever(function () {\n\n    player.checkCollision(obstacle);\n\n    \n    \n    basic.pause(200)\n        if (!(obstacle.isActiveObs())) {\n            // Mostra o obstáculo na posição inicial (4, 4)\n            obstacle.spawn();\n        } else {\n            // Move o obstáculo para a esquerda\n            obstacle.move();\n   }\n})\n","README.md":"","player.ts":"class Player {\n    private sprite: game.LedSprite;\n    private isJumping: boolean = false;\n    private collision: number = 0;\n    private lives: game.LedSprite[] = []; // Array para armazenar os sprites de vida\n    private score: number = 0;\n\n    constructor() {\n        // Cria um sprite na posição inicial (1, 4)\n        this.sprite = game.createSprite(1, 4);\n        this.initializeLives(); // Inicializa as vidas\n    }\n\n    // Método para inicializar as vidas\n    private initializeLives(): void {\n        for (let i = 0; i < 3; i++) {\n            this.lives.push(game.createSprite(i, 0)); // Cria um sprite de vida na posição (i, 0)\n        }\n    }\n\n    // Método para atualizar a posição do sprite\n    setPosition(y: number): void {\n        this.sprite.setY(y);\n    }\n\n    // Método para fazer o jogador pular\n    jump(): void {\n        if (this.isJumping === false) { // Verifica se o jogador já está pulando\n            this.isJumping = true; // Marca que o jogador está pulando\n\n            // Move o sprite para cima (pulo)\n            this.setPosition(3);\n            basic.pause(150);\n\n            this.setPosition(2);\n            basic.pause(150);\n\n            this.setPosition(3);\n            basic.pause(150);\n\n            // Retorna o sprite à posição original\n            this.setPosition(4);\n            basic.pause(200);\n\n            this.isJumping = false; // Marca que o pulo terminou\n        }\n    }\n\n    // Método para verificar colisões e atualizar vidas\n    public checkCollision(obstacle: Obstacle): void {\n        if (obstacle.getSpriteX() === 1 && this.sprite.get(LedSpriteProperty.Y) === 4) {\n            this.collision += 1; // Incrementa o contador de colisões\n            this.updateLives(); // Atualiza as vidas\n            \n        }\n    }\n\n    // Método para atualizar as vidas\n    private updateLives(): void {\n        if (this.collision <= this.lives.length) {\n            // Remove uma vida\n            let life = this.lives.pop();\n            if (life) {\n                life.delete(); // Remove o sprite da vida\n            }\n        }\n\n        // Verifica se o jogador perdeu todas as vidas\n        if (this.collision >= 3) {\n            game.gameOver(); // Fim de jogo\n        }\n    }\n}","obstacle.ts":"class Obstacle {\n    private sprite: game.LedSprite; // Sprite do obstáculo\n    private isActive: boolean; // Indica se o obstáculo está ativo na tela\n\n    constructor() {\n        // Cria o sprite do obstáculo, inicialmente invisível\n        this.sprite = game.createSprite(4, 4); // Posição inicial (4, 4)\n        this.sprite.setBrightness(0); // Inicialmente invisível\n        this.isActive = false; // Obstáculo começa inativo\n    }\n\n    // Método para ativar o obstáculo na posição inicial (4, 4)\n    public spawn(): void {\n        if (!this.isActive) { // Só ativa se o obstáculo não estiver ativo\n            this.sprite.setX(4); // Posição X inicial\n            this.sprite.setY(4); // Posição Y fixa\n            this.sprite.setBrightness(100); // Torna o obstáculo visível\n            this.isActive = true; // Marca o obstáculo como ativo\n        }\n    }\n\n    // Método para mover o obstáculo para a esquerda\n    public move(): void {\n        if (this.isActive) { // Só move se o obstáculo estiver ativo\n            const currentX = this.sprite.x(); // Pega a posição X atual\n            if (currentX > 0) { // Se não chegou ao fim (0, 4)\n                this.sprite.move(-1); // Move para a esquerda\n            } else { // Se chegou ao fim (0, 4)\n                this.despawn(); // Remove o obstáculo\n            }\n        }\n    }\n\n    // Método para remover o obstáculo da tela\n    public despawn(): void {\n        this.sprite.setBrightness(0); // Torna o obstáculo invisível\n        this.isActive = false; // Marca o obstáculo como inativo\n    }\n\n    // Método para verificar se o obstáculo está ativo\n    public isActiveObs(): boolean {\n        return this.isActive;\n    }\n\n    public getSpriteX(): number {\n        return this.sprite.x();\n    }\n}","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"player.ts\",\n        \"obstacle.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1740239753361}